给定两个大小为 m 和 n 的有序数组  nums1 和  nums2。

- 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为  O(log(m + n))。
- 你可以假设  nums1  和  nums2  不会同时为空。

```cpp
示例 1:
nums1 = [1, 3]
nums2 = [2]
则中位数是 2.0

示例 2:
nums1 = [1, 2]
nums2 = [3, 4]
则中位数是 (2 + 3)/2 = 2.5
```

---

中位数

如果数组是奇数个，则中位数是下标为(len-1)/2 的那一个
如果是偶数个，则中位数是下标为 len/2-1 和 len/2 两个数的平均数

---

求两个有序数组中第 K 小的数的特殊情况

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findKthArrays = function (nums1, nums2, k) {
  function dfs(nums1, nums2, start1, end1, start2, end2, k) {
    if (start1 == end1) return nums2[start2 + k - 1];
    if (start2 == end2) return nums1[start1 + k - 1];
    if (k == 1) return Math.min(nums1[start1], nums2[start2]);
    let i = k >> 1;
    if (start1 + i >= nums1.length) {
      // s1到头了
      if (nums1[nums1.length - 1] >= nums2[start2 + i - 1]) {
        return dfs(nums1, nums2, start1, end1, start2 + i, end2, k - i);
      }
      return dfs(
        nums1,
        nums2,
        end1,
        end1,
        start2,
        end2,
        k - nums1.length + start1
      ); // 去掉s1剩余部分
    }

    if (start2 + i >= nums2.length) {
      // s2到头了
      if (nums1[start1 + i - 1] < nums2[nums2.length - 1]) {
        // 去掉s1前半部分
        return dfs(nums1, nums2, start1 + i, end1, start2, end2, k - i);
      }
      return dfs(
        nums1,
        nums2,
        start1,
        end1,
        end2,
        end2,
        k - nums2.length + start2
      ); // 去掉s2剩余部分
    }
    if (nums1[start1 + i - 1] < nums2[start2 + i - 1]) {
      // 去掉s1前半部分
      return dfs(nums1, nums2, start1 + i, end1, start2, end2, k - i);
    } else {
      // 去掉s2前半部分
      return dfs(nums1, nums2, start1, end1, start2 + i, end2, k - i);
    }
  }

  return dfs(nums1, nums2, 0, nums1.length, 0, nums2.length, k);
};

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function (nums1, nums2) {
  let size = nums1.length + nums2.length;
  let mid = (size + 1) >> 1;
  if (size % 2 == 1) return findKthArrays(nums1, nums2, mid);
  return (
    (findKthArrays(nums1, nums2, mid) + findKthArrays(nums1, nums2, mid + 1)) /
    2
  );
};
```
