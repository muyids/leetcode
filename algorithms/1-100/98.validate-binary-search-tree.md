
## 深度优先搜索

分析

递归所有节点满足，二叉树的左孩子 < 根, 右孩子 > 根

代码

```javascript
var isValidBST = function(root) {

    function dfs(root){
        if (root == null){
            return true
        }
        if (root.left){
            if (root.left.val >= root.val) return false
        }
        if (root.right){
            if (root.right.val <= root.val) return false
        }

        return dfs(root.left) && dfs(root.right)
    }

    return dfs(root)
};
```

但是这样也不一定正确，如下面的case就不通过

[10,5,15,null,null,6,20] 返回true,期望false

实际上BST，需要整个右子树都大于根，整个左子树都小于根

前面已经判断了，右孩子一定大于根，左孩子一定小于根；

需要再附加条件：**任意节点的值必须大于其左子树的最右节点；同时小于右子树的最左节点。从根节点开始检查，一旦发现不满足则返回false。**

整理代码

```javascript
var isValidBST = function(root) {

    function dfs(root){
        if (root == null ){
            return true
        }
        if (root.left){
            if (root.left.val >= root.val) return false
            let rightest = getRightest(root.left)
            if (rightest && root.val <= rightest.val) return false

        }
        if (root.right){
            if (root.right.val <= root.val) return false
            let leftest = getLeftest(root.right)
            if (leftest && root.val >= leftest.val) return false
        }

        return dfs(root.left) && dfs(root.right)
    }

    function getRightest(node){
        while (node && node.right) node = node.right
        return node
    }

    function getLeftest(node){
        while (node && node.left) node = node.left
        return node
    }

    return dfs(root)
};
```

自上往下递归，传入当前子树所有值应该在的区间

		x [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]
	y		z
m	n		p	q

y取值 [Number.MIN_SAFE_INTEGER, x-1]
z取值 [x+1, Number.MAX_SAFE_INTEGER]
依次递推

```javascript
var isValidBST = function(root) {
    function dfs(root, low, high){
        if (root == null) return true
        if (root.left && root.left.val >= root.val)return false
        if (root.right && root.right.val <= root.val)return false
        if (root.left && root.left.val < low) return false
        if (root.right && root.right.val > high) return false
        return dfs(root.left, low, root.val-1) && dfs(root.right, root.val+1, high)
    }
    return dfs(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)
};

```

### 中序遍历

```javascript
var isValidBST = function(root) {
    var queue = []
    function dfs(root){
        if (!root) return
        if (root.left) dfs(root.left)
        if (root) queue.push(root.val)
        if (root.right) dfs(root.right)
    }

    dfs(root)

    for (let i =0; i< queue.length-1; i++){
        if (queue[i] >= queue[i+1]) return false
    }

    return true
};
```
