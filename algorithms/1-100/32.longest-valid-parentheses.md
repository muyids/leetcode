给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

```cpp
示例 1:

输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
示例 2:

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

---

## 栈思路

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> stk;
        int start = 0; // 一个可能的合法括号串的开始
        int ans = 0;
        for (int i = 0; i< s.size(); i++){
            if (s[i] == '('){
                stk.push(i);
            } else {
                if (stk.empty()){
                    start = i+1;
                } else {
                    stk.pop();
                    if (stk.empty()){
                        ans = max(ans, i - start + 1);
                    } else {
                        ans = max(ans, i - stk.top());
                    }
                }
            }
        }
        return ans;
    }
};
```

## 动态规划

分析

) ( ( ) ) ) ( ( ( ) ) ( ( ) ) ( ) ) ( )

dp[i]表示位置i结尾的有效子串的长度

```cpp
如果s[i] == '(' , dp[i] = 0
如果s[i] == ')'
    如果s[i-1] == '(', dp[i] = 2 + dp[i-2] // 当前位置结尾的闭括号区间（长度为2） + 前一段有效括号子串长度(dp[i-2])
    如果s[i-1] == ')', 如果 则前一个位置结尾的有效长度为dp[i-1], 只有当 s[i - dp[i-1] -1] == '('时，s[i]可以作为有效子串的最后一个位置，此时s[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]; 否则，如果
    i - dp[i-1] -1 < 0 || s[i - dp[i-1] -1] == ')'，则dp[i]= 0
```

())

javascript

```javascript
var longestValidParentheses = function(s) {
   if (s.length == 0) return 0
   let dp = new Array(s.length).fill(0)
   for (let i = 0; i< s.length; i++){
        if (s[i] == '(') continue
        if (s[i-1] == '('){
           if (i - 2 <0) dp[i] = 2
           else dp[i] = 2 + dp[i-2]
        } else if (s[i-1] == ')'){
            if (i - dp[i-1] -1 < 0 || s[i - dp[i-1] -1] == ')'){
               dp[i] = 0
            } else {
                if (i-dp[i-1]-2 < 0 ) dp[i] = dp[i-1] + 2
                else dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]
            }
       }
   }
   return Math.max(...dp)
};
```

cpp

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        int ans = 0;
        vector<int> dp(s.size(), 0);
        for (int i = 1; i< s.size(); i++){
            if (s[i] == '(') continue; // 位置是(，长度都为0
            if (s[i-1] == '(')  dp[i] = 2; // "()"
            else {// "...))))"的情况
                if (i - dp[i-1] -1 >= 0 &&s[i - dp[i-1] -1] == '(') {
                    dp[i] = dp[i-1] + 2;
                }
            }
            if (i-dp[i] >=0 && s[i-dp[i]]==')') { // 拼前一段；()(()) 的情况
                dp[i] += dp[i-dp[i]];
            }
            ans = max(dp[i], ans);
        }
        return ans;
    }
};
```
