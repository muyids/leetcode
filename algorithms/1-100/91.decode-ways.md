# 题意

将 数字 解码成 字母，求方案数

编码方式：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

比如：

- 11 可能是（1 1) => "AA" , 也可能是 (11) => "K"
- 11106，可能是 (1 1 10 6) => "AAJF"，也可能是 (11 10 6) => "KJF"

# 线性 DP

## 状态表示

- $f[i]$ 表示 以位置 i 结尾的串有多少种解码方式

## 状态转移：

我们的关注点 在 以 i 结尾的子串的解码上，

因为，字母最多有两位数字编码得到，所以 解码方案数 $f[i]$ 可以由 两个子状态 转化而来，也就是 $f[i-1]$ 和 $f[i-2]$；

状态转化的规则 跟 $s[i-1, i]$ 的子串代表的数字 有关，我们对其进行具体分析：

| 第 i-1 个位置 | 第 i 个位置 | 状态装换                                                                                                          |
| ------------- | ----------- | ----------------------------------------------------------------------------------------------------------------- |
| 0             | 0，1-9      | $s[i] == 0$时，返回 0；<br/>$s[i]∈[1,9]$时，$f[i] = f[i-1]$                                                       |
| 1             | 0, 1-9      | $s[i] == 0$时，$f[i] = f[i-2]$；<br/>$s[i]∈[1,9]$时，$f[i] = f[i-1] + f[i-2]$                                     |
| 2             | 0，1-6, 7-9 | $s[i] == 0$时，$f[i] = f[i-2]$；<br/>$s[i]∈[1,6]$时，$f[i] = f[i-1] + f[i-2]$<br/>$s[i]∈[7,9]$时，$f[i] = f[i-1]$ |
| 3-9           | 0，1-9      | $s[i] == 0$时，返回 0；<br>$s[i]∈[1,9]$时，$f[i] = f[i-1]$                                                        |

结合上面的 DP table，状态转化方程 也就不难列出了：

当 $s[i-1, 1]$ 属于下面的情况时，

- 当 $[0,0]$，$[3-9, 0]$ 时， 返回 $0$
- 当 $[0,1-9]$ 、$[2, 7-9]$、$[3-9, 1-9]$时， $f[i] = f[i-1]$
- 当 $[1,0]$、$[2,0]$时，$f[i] = f[i-2]$
- 当 $[1,1-9]$、$[2, 1-6]$ 时，$f[i] = f[i-1] + f[i-2]$

## 边界：

- $f[0] = 1$，初始化值
- $f[1]$ 当 $i == 0$，也就是 $s[0]$ 的情况边界值

## 代码实现

```java []
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int f[] = new int[n+1];
        f[0] = 1;
        char[] sc = s.toCharArray();
        if (sc[0] == '0') return 0;
        f[1] = 1;
        // 因为加了一个起始边界位置，此时字符位置为 i-1
        for (int i = 2; i <= n; i++){
            char c = sc[i-1], lastc = sc[i-2];
            if (c == '0') {
                if (lastc != '1' && lastc != '2') return 0;
                f[i] = f[i-2];
                continue;
            }
            f[i] = f[i-1];
            if ((lastc == '1' && c != '0')
                || (lastc == '2' && c >= '1' && c <='6')) {
                f[i] += f[i-2];
            }
        }
        return f[n];
    }
}
```

```cpp []
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;
        if (s[0] == '0'|| (s[1] == '0' && (s[0] != '1' && s[0] != '2'))) return 0;
        for (int i = 2; i<=n; i++){
            if (s[i] == '0') {
                if (s[i-1] != '1' && s[i-1] != '2') return 0;
                dp[i] = dp[i-2];
                continue;
            } else if (s[i-1] == '0') {
                dp[i] = dp[i-2];
                continue;
            }
            dp[i] += dp[i-1];
            int k = atoi(s.substr(i-2, 2).c_str());
            if (k >=10 && k<= 26) dp[i] += dp[i-2];
        }
        return dp[n];
    }
};
```

## 滚动数组

```cpp
class Solution {
public:
    int numDecodings(string s) {
        if (s.size() == 0 || s[0] == '0') return 0;
        if (s.size() == 1) return 1;
        int dp[3];
        dp[1] = 1;
        if (s[1] == '0'){
            if (s[0] == '0' || s[0] - '0' > 2) return 0;
            else dp[2] = 1;
        }else {
            int k = (s[0] - '0') * 10 + s[1] - '0';
            if (k >=11 && k<= 26)dp[2] = 2;
            else dp[2] = 1;
        }

        for (int i = 2; i< s.size(); i++){
            dp[0] = dp[1];
            dp[1] = dp[2];
            if (s[i] == '0') {
                if (s[i-1] == '0' || s[i-1] - '0' > 2) return 0;
                dp[2] = dp[0];
            }
            else if ((s[i-1] - '0') * 10 +s[i] - '0' >=10 && (s[i-1] - '0') * 10 + s[i] - '0' <= 26){
                dp[2] = dp[1] + dp[0];
            }else {
                dp[2] = dp[1];
            }
        }
        return dp[2];
    }
};
```

# 总结

当遇到这种状态转换情况比较多的 DP 题目时，最好的解题方式是画出 DP Table，枚举所有情况分析后得出动态转化方程
