给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

```cpp
示例:

输入:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
输出: 6
```

---

## 单调栈

- 根据84题的灵感，以每一行为底，求当前行的最大矩形
- 迭代得到整个矩阵的最大矩形

### 代码实现

```javascript
var maximalRectangle = function(matrix) {
    if (matrix.length ==0) return 0
    let maxArea = 0;
    for (let i = 0; i< matrix[0].length; i++) matrix[0][i] = +matrix[0][i]
    for (let i = 1; i < matrix.length; i++ ){
        for (let j =0; j< matrix[0].length; j++){
            if (matrix[i][j] == 0) continue
            matrix[i][j] = +matrix[i-1][j] + +matrix[i][j]
        }
    }
    for (let i = 0; i< matrix.length; i++){
        maxArea = Math.max(maxArea,largestRectangleArea(matrix[i]) )
    }
    return maxArea
};

var largestRectangleArea = function (heights) {
    let maxArea = 0 , stack = []
    heights.push(0) // 压入0，使单调栈所有元素弹出
    for (let i =0; i< heights.length; i++){
       while (stack.length > 0 && heights[stack[stack.length -1]] >= heights[i]){
           let now = stack.pop() // 出栈
           let l = stack.length == 0 ? -1 : stack[stack.length-1] // 左边第一个比heights[now]小的位置
           maxArea = Math.max(maxArea, heights[now]  * (i -l -1))
       }
       stack.push(i)
    }
    return maxArea
};
```
