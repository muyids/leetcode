在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。

「黑皇后」在棋盘上的位置分布用整数坐标数组 queens 表示，「白国王」的坐标用数组 king 表示。

「黑皇后」的行棋规定是：横、直、斜都可以走，步数不受限制，但是，不能越子行棋。

请你返回可以直接攻击到「白国王」的所有「黑皇后」的坐标（任意顺序）。

```cpp
示例 1：

输入：queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]
输出：[[0,1],[1,0],[3,3]]
解释：
[0,1] 的皇后可以攻击到国王，因为他们在同一行上。
[1,0] 的皇后可以攻击到国王，因为他们在同一列上。
[3,3] 的皇后可以攻击到国王，因为他们在同一条对角线上。
[0,4] 的皇后无法攻击到国王，因为她被位于 [0,1] 的皇后挡住了。
[4,0] 的皇后无法攻击到国王，因为她被位于 [1,0] 的皇后挡住了。
[2,4] 的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。
```

提示：

- 1 <= queens.length <= 63
- queens[0].length == 2
- 0 <= queens[i][j] < 8
- king.length == 2
- 0 <= king[0], king[1] < 8
- 一个棋盘格上最多只能放置一枚棋子。

---

思路

思路简单，八个方向查找，遇到王后，push到结果集

```javascript
/**
 * @param {number[][]} queens
 * @param {number[]} king
 * @return {number[][]}
 */
var queensAttacktheKing = function (queens, king) {
    let board = new Array(8)
    for (let i = 0; i < 8; i++) {
        board[i] = new Array(8)
    }
    for (let q of queens) {
        board[q[0]][q[1]] = 'o'
    }
    let ans = []

    let direction = [
        [1, 0], // 右
        [-1, 0], // 左
        [0, 1], //上
        [0, -1], //下
        [1, -1], // 右上
        [-1, 1], // 左下
        [1, 1], // 右下
        [-1, -1] // 左上
    ]
    for (let i = 0; i < direction.length; i++) {
        for (let k = 1; k <= 7; k++) {
            let x = king[0] + direction[i][0] * k
            let y = king[1] + direction[i][1] * k
            if (x < 0 || x > 7 || y < 0 || y > 7) {
                break
            }
            if (board[x][y] == 'o') {
                ans.push([x, y])
                break
            }
        }
    }
    return ans
};

```
