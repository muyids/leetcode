给定整数  n  和  k，找到  1  到  n  中字典序第  k  小的数字。

注意：1 ≤ k ≤ n ≤ 109。

```cpp
示例 :

输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```

---

## 算法思路

- 画出字典树
- k 表示要找到后面的第 k 个元素，起始下标是 0
- 获取以 prefix 开头的数字个数，包括他本身
  - 如果数字个数大于 k，下移，在 prefix\*10 下的子树进行查找
  - 如果数字个数小于等于 k，右移，在 prefix+1 下的子树进行查找

问题的关键是求解 以 prefix 开头的数字个数，包括他本身

- 根节点 `[prefix, prefix+1 )`
- 第一层 `[prefix*10, (prefix+1)*10 )`
- 第二层 `[prefix*100, min(n+1, (prefix+1)*100) )`
- ...

## 代码实现

```cpp
class Solution {
public:
typedef long long LL;
    int findKthNumber(int n, int k) {
        int prefix = 1;
        k--; // k记录要找的数字在prefix后的第几个
        while (k>0){
            int cnt = getCnt(n, prefix); // 当前prefix 下有多少个元素;包含prefix
            if (cnt <= k) { // 向右
                k -= cnt;
                prefix++;
            } else { // 向下
                k--;
                prefix*=10;
            }
        }
        return prefix;
    }
    int getCnt(LL n, LL prefix){
        LL cnt = 0;
        for (LL first = prefix, second = prefix+1; first<=n; first*=10, second*=10){
            cnt+= min(n + 1, second) - first;
        }
        return cnt;
    }
};
```

## 求字典序第 K 的答案

在《算法问题实战策略》中曾遇到了这样一类问题（其实也只有两道）。第一道是在 204 页，题目大意是求字典序第 k 的由两个字符构成的串，这道题，很简单，只需要统计以这个字符开头的串的个数，然后看情况跳，跳不了就不断递归下去。

但这揭示了这类问题的一般方案：

一，先按字典序设计穷举算法，然后将其改为动态规划法（解决计数问题）。二，设计一个递归过程，初始化 skip 为 k-1。统计答案，若 skip 大于当前答案个数，则 skip-=当前答案个数，继续尝试下一个选择，重复过程。直到或者一开始就 skip<=当前答案，选择成功，进入下一次递归。最后，设计终止条件（书中叫初始条件），则得解。

一道非常重要的例题是 209 页的`K-LIS`问题，这道题书上标注为难度高，其实是非常中（jian)等(dan)的一道题。题目要求字典序第 k 的 LIS。

在这道题里，就很好的体现了上面所提到的方法。说起来大概是这样：第一步，按字典序生成所有元素开头的 LIS 长度（是为了方便判断怎样的子序列才是 LIS）。第二步，按字典序生成所有排列（注意喽，千万不是老实生成所有排列，只是按照递归产生所有排列，后面还要加东西进来的）。第三步，解决计数问题。接下来，就只剩下按照递归过程生成就行了，关键就是一个字“跳”。

这个就完美 KO 了，一个问题是，书中解答使用了排序，因此产生了 nlgn 的排序时间。书中最后提到可以把复杂度下降。一个显然的方案是这样，从小到大枚举 next，如果符合要求，就进行相关操作。由于是 LIS，因此必定单调递增，这样算下来总的复杂度便只有 O（n 平方）。像这样的问题分析复杂度，不能用循环的次数去乘某个式子，而是要看所有这 n 次循环后，关键变量增加的总和。在这里 next 单增，所以最多循环不超过 n 次（当然，整个数组的排序是免不了的）。
