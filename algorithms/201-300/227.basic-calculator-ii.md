实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。

示例 1:

输入: "3+2*2"
输出: 7
示例 2:

输入: " 3/2 "
输出: 1
示例 3:

输入: " 3+5 / 2 "
输出: 5
说明：

你可以假设所给定的表达式都是有效的。
请不要使用内置的库函数 eval。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/basic-calculator-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

类似题目150，224，227

---

字符串表达式为中缀表达式，求值使用后缀表达式

所以要先把中缀表达式转换为后缀表达式（逆波兰式），然后再根据150题的算法求值

-----

具体规则为：
1.中缀转后缀：
中缀表达式a + b*c + (d * e + f) * g，其转换成后缀表达式则为a b c * + d e * f  + g * +。
转换过程需要用到栈，具体过程如下：
1）如果遇到操作数，我们就直接将其输出。
2）如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中。
3）如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。注意，左括号只弹出并不输出。
4）如果遇到任何其他的操作符，如（“+”， “*”，“（”）等，从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止。
弹出完这些元素后，才将遇到的操作符压入到栈中。有一点需要注意，只有在遇到" ) "的情况下我们才弹出" ( "，其他情况我们都不会弹出" ( "。
5）如果我们读到了输入的末尾，则将栈中所有元素依次弹出。

2.计算后缀：
- 遇到数字，入栈
- 遇到运算符，弹出栈顶两个元素，做运算，并将结果入栈
- 重复上述步骤，直到表达式最右端

-----

```javascript
var evalRPN = function (tokens) {
    let stack = []
    for (let c of tokens) {
        let a, b
        switch (c) {
            case "+":
                b = stack.pop()
                a = stack.pop()
                stack.push(a + b)
                break
            case "-":
                b = stack.pop()
                a = stack.pop()
                stack.push(a - b)
                break
            case "*":
                b = stack.pop()
                a = stack.pop()
                stack.push(a * b)
                break
            case "/":
                b = stack.pop()
                a = stack.pop()
                stack.push(parseInt(a / b))
                break
            default:
                stack.push(+c)
                break
        }
    }
    return stack[0]
};

// 中缀转后缀
function midToBack(s) {
    s = s.replace(/\s*/g, "")
    let midExp = [] // 解析成中缀表达式
    for (let i = 0; i < s.length;) {
        for (let j = i; j < s.length; j++) {
            if (s[j] == '+' || s[j] == '-' || s[j] == '*' || s[j] == '/') {
                if (j == i) {
                    midExp.push(s[j])
                } else {
                    midExp.push(+s.substr(i, j - i))
                    midExp.push(s[j])
                }
                i = j + 1
                break
            } else if (j == s.length - 1) {
                if (j == i) {
                    midExp.push(+s[j])
                } else {
                    midExp.push(+s.substr(i, j - i + 1))
                }
                i = j + 1
                break
            }
        }
    }

    let opStack = []
    let backExp = []
    for (let c of midExp) {
        if (typeof c == 'number') { // 操作数
            backExp.push(c)
        } else {
            if (opStack.length == 0) opStack.push(c)
            else {// 弹出操作符知道发现更低优先级的元素
                while (opCompare(opStack[opStack.length - 1], c)) {
                    backExp.push(opStack.pop())
                }
                opStack.push(c)
            }
        }
    }
    while (opStack.length > 0) backExp.push(opStack.pop())
    return backExp
}

function opCompare(x, y) {// true:x>y
    let op = {
        "+": 1,
        "-": 1,
        "*": 2,
        "/": 2
    }
    return op[x] >= op[y]
}

var calculate = function (s) {
    return evalRPN(midToBack(s))
};
```

