你将获得  K  个鸡蛋，并可以使用一栋从  1  到  N   共有 N  层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层  F ，满足  0 <= F <= N 任何从高于 F  的楼层落下的鸡蛋都会碎，从  F  楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层  X  扔下（满足  1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

```cpp
示例 1：

输入：K = 1, N = 2
输出：2

解释：

- 鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
- 否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
- 如果它没碎，那么我们肯定知道 F = 2 。
- 因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。

示例 2：

输入：K = 2, N = 6
输出：3

示例 3：

输入：K = 3, N = 14
输出：4
```

提示：

- 1 <= K <= 100
- 1 <= N <= 10000

---

## DP O(K\*N^2)

- f[i, j]表示 i 层楼，j 个鸡蛋的测量方案中最坏情况的最小值
- j 个鸡蛋在足够多的情况下可以不用全部用完

状态转移：

- 不使用第 j 个鸡蛋(鸡蛋在足够多的情况)，方案数为`f[i, j - 1]`
- 使用第 j 个鸡蛋，则有`1~i`层楼共 i 种情况可以扔，假设在第 k 层扔：
  - 蛋碎，搜索区间变成`1~k-1`，鸡蛋个数减一，方案数为`f[k - 1, j - 1]`
  - 蛋没碎，搜索区间变成`k+1~i`，第 j 个蛋可重复利用，方案数为`f[i - k, j]`
- 枚举扔的楼层 k，在所有可行方案中选择最大值即为最坏情况，答案就是这些情况的最小值

### 代码实现

```cpp
class Solution {
public:
    int superEggDrop(int K, int N) {
        vector<vector<int>> dp(N+1, vector<int>(K+1, 0));
        for (int i = 1; i<= N ; i++) dp[i][1] = i;
        for (int i = 1; i <= K; i++) dp[1][i] = 1;
        for (int i = 2; i <=N; i++){ // 枚举楼层
            for (int j = 2; j <= K; j++){ // 枚举鸡蛋个数
                dp[i][j] = dp[i][j-1]; // 不需要第j个鸡蛋
                for (int k = 1; k <= i; k++){ // 在第k层扔
                    dp[i][j] = min(dp[i][j], max(dp[k-1][j-1], dp[i-k][j]) + 1); // 不碎和碎了两种情况，取最大值（最坏情况）+ 操作1次
                }
            }
        }
        return dp[N][K];
    }
};
```

时间复杂度 O(K\*N^2)

当`N=10000`时，超时

## DP O(KN)

- f[i, j]表示用 j 个鸡蛋测量 i 次能测量的区间长度的最大值
- 枚举扔鸡蛋的楼层 k，类似上面枚举 k 层楼扔鸡蛋，没碎测 k 楼以上，碎了测 k 楼以下，那么能测的最大高度就是上下两部分加上第 k 层楼这一层

### 代码实现

```cpp
class Solution {
public:
    int superEggDrop(int K, int N) {
        int dp[10010][110];
        for (int i = 1; i<= N; i++){
            for (int j = 1; j <= K;j++){
                dp[i][j] = max(dp[i][j], dp[i-1][j] + dp[i-1][j-1] + 1);
                if (dp[i][j] >= N) return i;
            }
        }
        return N;
    }
};
```
