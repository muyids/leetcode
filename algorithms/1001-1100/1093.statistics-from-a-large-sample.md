我们对  0  到  255  之间的整数进行采样，并将结果存储在数组  count  中：count[k]  就是整数  k 的采样个数。

我们以   浮点数   数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。

我们先来回顾一下中位数的知识：

如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；
如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。

示例 1：

输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
示例 2：

输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
输出：[1.00000,4.00000,2.18182,2.00000,1.00000]

提示：

count.length == 256
1 <= sum(count) <= 10^9
计数表示的众数是唯一的
答案与真实值误差在  10^-5  以内就会被视为正确答案

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/statistics-from-a-large-sample
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

元素是无序的，难点在于求中位数

大样本求中位数，可以用最大堆和最小堆

这个题，数据为[0，255]的整数，可以用字典，统计数字出现个数

---

```javascript
var sampleStats = function (count) {
  let result = [];

  let min, max, avg, mid, most;
  let sum = 0,
    counter = 0,
    mostCounter = 0;
  for (let i = 0; i <= 255; i++) {
    if (min === undefined && count[i] > 0) {
      min = i;
    }
    if (count[i] > 0) {
      max = i;
    }
    sum = sum + i * count[i];
    counter += count[i];

    if (mostCounter < count[i]) {
      most = i;
      mostCounter = count[i];
    }
  }

  for (let i = 0, pos = 0; i <= 255; i++) {
    pos += count[i];
    if (counter % 2 !== 0) {
      if (pos >= counter / 2) {
        mid = i;
        break;
      }
    } else {
      // 中间两个数的平均数
      if (pos === counter / 2) {
        for (let j = i + 1; j <= 255; j++) {
          if (count[j] > 0) {
            mid = (i + j) / 2;
            break;
          }
        }
        break;
      } else if (pos > counter / 2) {
        mid = i;
        break;
      }
    }
  }

  avg = sum / counter;

  for (let i = 255; i >= 0; i--) {
    if (count[i] > 0) {
      result.push(count[i]);
    }
  }

  return [min, max, avg, mid, most];
};
```
