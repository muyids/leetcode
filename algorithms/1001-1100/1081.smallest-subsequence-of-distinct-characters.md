返回字符串 text 中按字典序排列最小的子序列，该子序列包含 text 中所有不同字符一次。

```cpp
示例 1：
输入："cdadabcc"
输出："adbc"

示例 2：
输入："abcd"
输出："abcd"

示例 3：
输入："ecbacba"
输出："eacb"

示例 4：
输入："leetcode"
输出："letcod"
```

提示：

- 1 <= text.length <= 1000
- text 由小写英文字母组成

---

求按字典序排列的最小子序列，该子序列包含 text 中所有不同字符一次。

首先要明确两个概念

1. 字典序排列

    字典序就是按照字典中出现的顺序进行排列

2. 子序列

    子序列不同于连续子序列，
    字符出现顺序与原序列一致

本题目要求在所有满足条件的子序列（包含text所有不同字符一次，即不重不漏）中，得到字典序最小的

我们很容易想到贪心算法，局部最优一定是全局最优，从头遍历字符串，使用栈去保存当前最优状态

---

贪心+栈+字典

- 贪心算法，栈保存当前最优状态
- 字典记录字符出现最后位置

---

优化，使用字典记录字符出现的最终位置，优化查找过程

```javascript
var smallestSubsequence = function (text) {
    let stack = []  // 记录当前最优解
    let last = {}  // 记录最后出现位置
    for (let i = 0; i < text.length; i++) {
        last[text[i]] = i
    }
    for (let i = 0; i < text.length; i++) {
        let index = stack.indexOf(text[i])
        if (index > -1) continue
        while (stack.length > 0 && stack[stack.length - 1] > text[i] && last[stack[stack.length - 1] ] > i) {
            stack.pop()
        }
        stack.push(text[i])
    }
    return stack.join('')
};
```

运行结果

![AC.png](https://pic.leetcode-cn.com/f307c6c1e8c8a74dc56f8323edea35e0d0343ddb231a2b3456349d0f8bf2b7f4-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-03%2011.11.33.png)
