
在一个有向图中，节点分别标记为 0, 1, ..., n-1。这个图中的每条边不是红色就是蓝色，且存在自环或平行边。

red_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的红色有向边。类似地，blue_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的蓝色有向边。

返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的最短路径的长度，且路径上红色边和蓝色边交替出现。如果不存在这样的路径，那么 answer[x] = -1。


示例 1：

输入：n = 3, red_edges = [[0,1],[1,2]], blue_edges = []
输出：[0,1,-1]
示例 2：

输入：n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]
输出：[0,1,-1]
示例 3：

输入：n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]
输出：[0,-1,-1]
示例 4：

输入：n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]
输出：[0,1,2]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/shortest-path-with-alternating-colors
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

最短路径，广度优先搜索，搜索过置为已搜索，直到没有下一层

```javascript
/**
 * @param {number} n
 * @param {number[][]} red_edges
 * @param {number[][]} blue_edges
 * @return {number[]}
 */
var shortestAlternatingPaths = function(n, red_edges, blue_edges) {

	let result = Array(n).fill(-1)
	result[0] = 0

	let build = [
			[
				[0, 0, 's']
			]
		],
		floor = [],
		len = 0 // 楼层

	while (build[len].length > 0) {
		let last = build[len]

		for (let edge of last) {
			if (edge[2] == 'b') {
				for (let i = 0; i < red_edges.length; i++) {
					if (edge[1] == red_edges[i][0]) {
						red_edges[i].push('r')
						floor.push(red_edges[i])
						if (result[red_edges[i][1]] == -1) {
							result[red_edges[i][1]] = len + 1
						}
						red_edges.splice(i--, 1)
					}
				}
			} else if (edge[2] == 'r') {
				for (let i = 0; i < blue_edges.length; i++) {
					if (edge[1] == blue_edges[i][0]) {
						blue_edges[i].push('b')
						floor.push(blue_edges[i])
						if (result[blue_edges[i][1]] == -1) {
							result[blue_edges[i][1]] = len + 1
						}
						blue_edges.splice(i--, 1)
					}
				}
			} else if (edge[2] == 's') {
				for (let i = 0; i < red_edges.length; i++) {
					if (edge[1] == red_edges[i][0]) {
						red_edges[i].push('r')
						floor.push(red_edges[i])
						if (result[red_edges[i][1]] == -1) {
							result[red_edges[i][1]] = len + 1
						}
						red_edges.splice(i--, 1)
					}
				}
				for (let i = 0; i < blue_edges.length; i++) {
					if (edge[1] == blue_edges[i][0]) {
						blue_edges[i].push('b')
						floor.push(blue_edges[i])
						if (result[blue_edges[i][1]] == -1) {
							result[blue_edges[i][1]] = len + 1
						}
						blue_edges.splice(i--, 1)
					}
				}
			}
		}
		len++
		build.push(floor)
		floor = []
	}
	return result
};
```
