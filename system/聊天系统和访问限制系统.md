# 设计一个聊天系统

## 场景Scenario

基本功能：

1. 两个用户点对点聊天
2. 群聊
3. 用户在线状态
4. 用户系统：用户登录注册，用户的通讯录（好友信息，群组）

其他功能：

1. 历史消息
2. 多机登录

以微信为例，估计QPS，存储

日活用户估计

1B月活，75%日活，约750M日活，假设我们要设计一个100M日活的聊天系统

QPS: 假设平均一个用户一天发送20条信息，Average QPS = 20 * 100 M / 100 K seconds = 20K

Peek QPS : 20K * 5 = 100K

存储：

每个用户发送 20条消息，1B日活用户，30bytes一条消息，20 * 1B * 30bytes = 60G

## 服务Service

Message Service: 负责消息管理

    - saveMsg
    - getMsgList

Real-time Service（Broker）: 实时消息推送

    Broker {Publisher, Subscriber}

User Service 用户服务

    登录，注册，通讯录等

## Storage存储

Message {
    id， from, to, content, created_at
}

如果这样设计，查询A和B的聊天消息，需要

select * from msgtable where from=A and to=B or from=B and to=A order by created_at desc;

问题：

1. SQL复杂，效率低下
2. 多人聊天，无法扩展

需要添加一个会话ID（sessionId）

两个人聊天，可以按 A和B的用户id 升序排列，中间分隔符隔开

另外，会话列表怎么实现？

增加session表

Session {
    ownerId, sessionId, participant_ids, is_muted, nickname, created_at, updated_at
}

优化消息表

Message {
    id，sessionId, from, content, created_at
}

选择存储类型SQL or NOSQL?

Message Table -> NoSQL : 数据量很大，不需要修改，一条聊天信息就像一条log一样

Session Table -- 对话表（SQL)

对话表需要的索引

    查询单个会话信息 ownerId + sessionId (primary key)

    查询会话列表 ownerId + updated_at
    select * from Session where ownerId=X order by updated_at desc

NoSQL对二级索引的支持并不友好，所以考虑SQL

100 个 会话消息, 10B用户， 1000 B 条消息，水平拆分 ， 用户id mod 10000 分为1万张表保存 会话表

---

群聊的消息如何推送？

以500人的群聊为例，实际上很少一部分人实时在线

我们需要知道谁是在线的

增加Channel Service（Topic Service）, 为每个会话增加一个Channel信息

用户登录时，需要先订阅对应的Channel；用户断线了，broker通知Channel移除掉

这样Channel就知道频道里哪些用户还活着

群发消息时，push给channel service, channel service查到在线用户，发给Push Service(Broker), 给在线用户推消息

---

在线离线状态更新

上线，主动下线 都向服务器上报状态
被动下线（网络断开等），使用心跳机制，每隔10秒上报自己的最后在线时间

请求用户在线状态时，使用拉的方式，判断最后在线时间是否在10秒内，如果不在，就是离线

facebook大概3-5秒pull一次服务器

---

Broker 机器数量：100 M 用户同时在线；单台机器 支持的 socket连接数可以达到65535

---

小知识

RateLimiter访问限制器

如何限制访问次数？

滑动窗口 -- 这其实是一道算法题


## 扩展学习

https://time.geekbang.org/column/article/137453
